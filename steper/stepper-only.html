<!DOCTYPE html>
<html lang="ar" dir="rtl" id="html-root">

<head id="head-section">
    <meta charset="UTF-8" id="meta-charset">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" id="meta-viewport">
    <title id="page-title" data-lkey="stepper_title">ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÇÿØŸÖ</title>
    <link rel="stylesheet" href="../assets/fontawesome/css/all.css" id="fontawesome-link">

    <!-- Shared Project Styles -->
    <link rel="stylesheet" href="../style/variables.css" />
    <link rel="stylesheet" href="../style/utilities.css" />
    <link rel="stylesheet" href="../style/modals-and-dialogs.css" />

    <link rel="stylesheet" href="style.css" id="main-stylesheet">

    <script src="../assets/libs/sweetalert2/sweetalert2.all.min.js" id="sweetalert-script"></script>

    <!-- Notification Dependencies -->
    <script src="../js/config.js"></script>
    <script src="../js/network.js"></script>
    <script src="../js/globalVariable.js"></script>
    <script src="../notification/notificationSetUp.js"></script>
    <script src="../notification/notificationTools.js"></script>
    <script src="../notification/notification-credentials.js"></script>
    <script src="../notification/notification-p2p-web.js"></script>
    <script src="../notification/notification-db-manager.js"></script>

    <!-- Auth Infrastructure (If needed) -->
    <script src="../js/auth/sessionManager.js"></script>

    <script>
        // Initialize userSession using SessionManager logic if available
        if (typeof SessionManager !== 'undefined') {
            SessionManager.init();
        } else {
            window.userSession = JSON.parse(localStorage.getItem("loggedInUser")) || null;
        }

        // Dark Mode Initialization
        function applyTheme() {
            const isDark = localStorage.getItem('theme') === 'dark';
            if (isDark) {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.remove('dark-theme');
            }
        }

        // Listen for storage changes to sync theme if changed in another tab/window
        window.addEventListener('storage', (e) => {
            if (e.key === 'theme') applyTheme();
        });

        // Apply on load (will be called in body onload or just script execution)
        window.addEventListener('DOMContentLoaded', applyTheme);

        // Localization Fallback for iFrame
        window.langu = function (key) {
            if (window.parent && typeof window.parent.langu === 'function') {
                const translation = window.parent.langu(key);
                // If the parent returns the key itself, it means the key is missing
                if (translation === key) {
                    // Provide a local fallback or return the key safely
                    const fallbacks = {
                        'loading_text': 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...'
                    };
                    return fallbacks[key] || key;
                }
                return translation;
            }
            return key;
        };

        window.applyAppTranslations = function () {
            document.querySelectorAll('[data-lkey]').forEach(el => {
                const key = el.getAttribute('data-lkey');
                el.textContent = window.langu(key);
            });
            document.querySelectorAll('[data-lkey-title]').forEach(el => {
                const key = el.getAttribute('data-lkey-title');
                el.setAttribute('title', window.langu(key));
            });
            document.querySelectorAll('[data-lkey-placeholder]').forEach(el => {
                const key = el.getAttribute('data-lkey-placeholder');
                el.setAttribute('placeholder', window.langu(key));
            });
        };
        window.addEventListener('DOMContentLoaded', window.applyAppTranslations);

        /**
         * Hides the application loading overlay.
         */
        window.hideAppLoader = function () {
            const loader = document.getElementById('app-loader');
            if (loader) {
                loader.style.opacity = '0';
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 400);
            }
        };
    </script>

    <style>
        /* Modern App Loader */
        #app-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary, #ffffff);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.4s ease;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--color-primary, #667eea);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        .loader-text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1rem;
            color: var(--text-primary, #2d3748);
            font-weight: 500;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        body.dark-theme #app-loader {
            background: #1a202c;
        }

        body.dark-theme .loader-text {
            color: #edf2f7;
        }
    </style>

    <script src="./main.js" type="module" id="main-script"></script>
    <script src="./dynamicGap.js" id="dynamic-gap-script"></script>
</head>

<body id="body-content">
    <!-- App Loading Overlay -->
    <div id="app-loader">
        <div class="loader-spinner"></div>
        <div class="loader-text" id="app-loader-text">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...</div>
    </div>

    <div class="step_container" id="main-container">
        <!-- ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä (ÿ™ŸÖ ŸÜŸÇŸÑŸá ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠) -->
        <main id="main-content">
            <!-- ÿßŸÑÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸÑŸÑÿ≠ÿßŸÑÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© -->


            <div class="stepper-container" id="primary-stepper-container">
                <div class="stepper-wrapper" id="primary-stepper-wrapper">
                    <!-- ÿßŸÑÿÆÿ∑Ÿàÿ© 1: ŸÖÿ±ÿßÿ¨ÿπÿ© -->
                    <div id="step-review" class="step-item review">
                        <div class="step-circle" id="step-review-circle">
                            <i class="fas fa-list-check" id="step-review-icon"></i>
                        </div>
                        <div class="step-label" id="step-review-label" data-lkey="step_review">ŸÖÿ±ÿßÿ¨ÿπÿ©</div>
                    </div>

                    <!-- ÿßŸÑÿÆÿ∑Ÿàÿ© 2: ŸÖÿ§ŸÉÿØ -->
                    <div id="step-confirmed" class="step-item confirmed">
                        <div class="step-circle" id="step-confirmed-circle">
                            <i class="fas fa-hand-peace" id="step-confirmed-icon"></i>
                        </div>
                        <div class="step-label" id="step-confirmed-label" data-lkey="step_confirmed">ŸÖÿ§ŸÉÿØ</div>
                    </div>

                    <!-- ÿßŸÑÿÆÿ∑Ÿàÿ© 3: ÿ¥Ÿèÿ≠ŸÜ (ŸÜÿ¥ÿ∑ÿ©) -->
                    <div id="step-shipped" class="step-item shipped">
                        <div class="step-circle" id="step-shipped-circle">
                            <i class="fas fa-truck" id="step-shipped-icon"></i>
                        </div>
                        <div class="step-label" id="step-shipped-label" data-lkey="step_shipped">ÿ¥Ÿèÿ≠ŸÜ</div>
                    </div>

                    <!-- ÿßŸÑÿÆÿ∑Ÿàÿ© 4: ÿ™ŸÖ ÿßŸÑÿ™ÿ≥ŸÑŸäŸÖ -->
                    <div id="step-delivered" class="step-item delivered">
                        <div class="step-circle" id="step-delivered-circle">
                            <i class="fas fa-box-open" id="step-delivered-icon"></i>
                        </div>
                        <div class="step-label" id="step-delivered-label" data-lkey="step_delivered">ÿ™ŸÖ ÿßŸÑÿ™ÿ≥ŸÑŸäŸÖ</div>
                    </div>
                </div>
            </div>

            <!-- ÿ≠ÿßŸàŸäÿ© ŸàÿµŸÅ ÿßŸÑÿÆÿ∑Ÿàÿ© -->
            <div id="step-description-container" class="step-description primary-description">
                <!-- ÿ≥Ÿäÿ™ŸÖ ÿ•ÿØÿ±ÿßÿ¨ ÿßŸÑŸàÿµŸÅ ŸáŸÜÿß ÿ®Ÿàÿßÿ≥ÿ∑ÿ© JavaScript -->
            </div>

            <!-- ÿ≠ÿßŸàŸäÿ© ÿ±ÿ≥ÿßŸÑÿ© ÿπÿØŸÖ ÿßŸÑÿ≥ŸÖÿßÿ≠ -->
            <div id="permission-denied-message" class="alert-message"></div>

            <!-- ÿ¥ÿ±Ÿäÿ∑ ŸÖŸÜŸÅÿµŸÑ ŸÑŸÑÿ≠ÿßŸÑÿßÿ™ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© -->
            <div class="stepper-container secondary-container" id="secondary-stepper-container">
                <div class="stepper-wrapper secondary-wrapper" id="secondary-stepper-wrapper">
                    <!-- ŸÖŸÑÿ∫Ÿä -->
                    <div id="step-cancelled" class="step-item cancelled">
                        <div class="step-circle" id="step-cancelled-circle">
                            <i class="fa-solid fa-circle-xmark" id="step-cancelled-icon"></i>
                        </div>
                        <div class="step-label" id="step-cancelled-label" data-lkey="step_cancelled">ŸÖŸÑÿ∫Ÿä</div>
                    </div>

                    <!-- ŸÖÿ±ŸÅŸàÿ∂ -->
                    <div id="step-rejected" class="step-item rejected">
                        <div class="step-circle" id="step-rejected-circle">
                            <i class="fas fa-thumbs-down" id="step-rejected-icon"></i>
                        </div>
                        <div class="step-label" id="step-rejected-label" data-lkey="step_rejected">ŸÖÿ±ŸÅŸàÿ∂</div>
                    </div>

                    <!-- ŸÖÿ±ÿ™ÿ¨ÿπ -->
                    <div id="step-returned" class="step-item returned">
                        <div class="step-circle" id="step-returned-circle">
                            <i class="fa-solid fa-arrow-rotate-left" id="step-returned-icon"></i>
                        </div>
                        <div class="step-label" id="step-returned-label" data-lkey="step_returned">ŸÖÿ±ÿ™ÿ¨ÿπ</div>
                    </div>
                </div>
            </div>

            <!-- ÿ≠ÿßŸàŸäÿ© ŸàÿµŸÅ ÿßŸÑÿÆÿ∑Ÿàÿßÿ™ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© (5-7) -->
            <div id="secondary-step-description-container" class="step-description secondary-description">
            </div>

            <!-- ‚úÖ ÿ¨ÿØŸäÿØ: ÿßŸÑÿ≠ÿßŸàŸäÿ© ÿßŸÑÿ≥ŸÅŸÑŸäÿ© ŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿÆÿØŸÖÿßÿ™ -->
            <div class="order-service-footer" id="orderServiceFooter">
                <div class="order-photo-link-container" id="orderPhotoLinkContainer">
                    <a href="#" id="orderPhotoLink" class="order-photo-link">
                        <i class="fas fa-images"></i> <span data-lkey="stepper_view_photos">ÿπÿ±ÿ∂ ÿµŸàÿ± ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑÿÆÿßÿµ</span>
                    </a>
                </div>
                <div class="order-value-input-container">
                    <label for="orderValueInput" data-lkey="stepper_order_value">ŸÇŸäŸÖÿ© ÿßŸÑÿ∑ŸÑÿ®:</label>
                    <div class="input-with-button">
                        <input type="number" id="orderValueInput" class="order-value-input" step="0.01"
                            placeholder="0.00">
                        <button id="orderValueSaveBtn" class="order-save-btn" data-lkey-title="stepper_save_value"
                            title="ÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäŸÖÿ©">
                            <i class="fas fa-save"></i>
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>
</body>

</html>
<script type="module">
    import { ordersData, appDataControl } from "./config.js";
    import { determineUserType } from "./roleAndStepDetermination.js";
    import { updateOrderTotalAmount } from "./dataFetchers.js";

    // Steps definition - static configuration for the stepper
    const DEFAULT_STEPS = [
        { id: "step-review", no: "1" },
        { id: "step-confirmed", no: "2" },
        { id: "step-shipped", no: "3" },
        { id: "step-delivered", no: "4" },
        { id: "step-cancelled", no: "5" },
        { id: "step-rejected", no: "6" }
    ];

    // User Permissions definition - static configuration
    const DEFAULT_USERS = [
        {
            type: "buyer",
            allowedSteps: ["step-review", "step-confirmed", "step-shipped", "step-delivered", "step-cancelled", "step-returned", "step-rejected"]
        },
        {
            type: "seller",
            allowedSteps: ["step-review", "step-confirmed", "step-shipped", "step-rejected", "step-cancelled", "step-delivered", "step-returned"]
        },
        {
            type: "courier",
            allowedSteps: ["step-confirmed", "step-shipped", "step-delivered", "step-cancelled", "step-rejected", "step-returned"]
        },
        {
            type: "admin",
            allowedSteps: ["step-review", "step-confirmed", "step-shipped", "step-delivered", "step-cancelled", "step-rejected", "step-returned"]
        }
    ];

    document.addEventListener('DOMContentLoaded', () => {
        let initRetries = 0;
        let dataBridgeRetries = 0;

        // 1. Data Bridging with Retry Logic
        function triggerDataBridge() {
            if (window.parent && window.parent.globalStepperAppData && window.initializeStepperData) {
                console.log("üîó [StepperOnly] Found parent data, bridging...");
                const parentData = window.parent.globalStepperAppData;

                window.globalStepperAppData = {
                    baseURL: parentData.baseURL
                };

                const control = {
                    baseURL: parentData.baseURL,
                    currentUser: {
                        idUser: parentData.idUser,
                        type: "unknown"
                    },
                    steps: DEFAULT_STEPS,
                    users: DEFAULT_USERS
                };
                const orders = parentData.ordersData || [];

                window.initializeStepperData(control, orders);
                console.log("üõ†Ô∏è [StepperOnly] Data injected successfully.");
                initPhotoLink();
            } else {
                dataBridgeRetries++;
                if (dataBridgeRetries < 20) { // Try for 2 seconds (100ms interval)
                    setTimeout(triggerDataBridge, 100);
                } else {
                    console.warn("‚ö†Ô∏è [StepperOnly] Initialization timeout: parent data or initializeStepperData missing.");
                    // Emergency hide after timeout if something is fatally wrong but we want the UI visible
                    setTimeout(window.hideAppLoader, 1000);
                }
            }
        }

        triggerDataBridge();

        // Update loader text with translation if available
        const loaderText = document.getElementById('app-loader-text');
        if (loaderText) {
            loaderText.textContent = window.langu('loading_text');
        }

        // 2. Auto-Scroll Tutorial (New)
        runStepperScrollTutorial();

        // 3. Photo Link Logic (Robust Recovery)
        const checkData = setInterval(() => {
            // Priority 1: Check internal data
            // Priority 2: Fallback to parent bridge directly
            const currentOrders = (ordersData && ordersData.length > 0) ? ordersData :
                (window.parent && window.parent.globalStepperAppData && window.parent.globalStepperAppData.ordersData);

            if (currentOrders && currentOrders.length > 0) {
                initPhotoLink(currentOrders);
                initRetries++;
                // We keep checking for a few times even after success in case of UI flickering
                if (initRetries > 5) clearInterval(checkData);
            }
        }, 1000);

        function initPhotoLink(activeOrders) {
            const data = activeOrders || ordersData;
            console.log("üîç [StepperOnly] initPhotoLink checking visibility...", {
                dataLength: data.length,
                retry: initRetries
            });

            const linkContainer = document.getElementById('orderPhotoLinkContainer');
            const link = document.getElementById('orderPhotoLink');
            const serviceFooter = document.getElementById('orderServiceFooter');
            const valueInput = document.getElementById('orderValueInput');
            const saveBtn = document.getElementById('orderValueSaveBtn');

            if (!serviceFooter) {
                console.warn("‚ö†Ô∏è [StepperOnly] orderServiceFooter not found yet.");
                return;
            }

            if (data.length > 0) {
                const order = data[0];
                const item = order.order_items && order.order_items[0];

                // Comprehensive Service Check
                const isServiceOrder = Number(order.orderType) === 1 ||
                    (order.order_items && order.order_items.some(i => Number(i.serviceType) === 1));

                console.log("[StepperOnly] Service Detection:", {
                    id: order.order_key,
                    isService: isServiceOrder,
                    orderType: order.orderType,
                });

                if (isServiceOrder) {
                    // Show Footer
                    serviceFooter.style.setProperty('display', 'flex', 'important');

                    // --- Role & Lock Specific Logic ---
                    const currentUser = (window.parent && window.parent.globalStepperAppData && window.parent.globalStepperAppData.idUser);
                    const role = determineUserType(currentUser, data, appDataControl);

                    // Logic to check if amount is locked
                    // Amount is locked for seller if:
                    // 1. Order status JSON has "__confirmation_locked_{sellerId}__" : "locked"
                    // 2. OR Order timeline has passed confirmation (Step ID >= confirmed)
                    const isConfirmed = order.order_status && (order.order_status.startsWith('step-confirmed') || order.order_status.startsWith('step-shipped') || order.order_status.startsWith('step-delivered'));

                    const sellerId = (role === "seller") ? currentUser : null;
                    const itemsMap = (typeof getAllItemsStatus === 'function') ? getAllItemsStatus() : {};
                    // We don't have direct access to internal locked keys here easily without parsing status,
                    // but the simple rule is: if order is confirmed/shipped/delivered, it's locked for seller.

                    const isLockedForSeller = (role === "seller" && isConfirmed);
                    const canEditAmount = (role === "admin") || (role === "seller" && !isLockedForSeller);

                    console.log("[StepperOnly] Price Protection:", { role, canEditAmount, isConfirmed, isLockedForSeller });

                    if (valueInput && saveBtn) {
                        // 1. Set Value
                        if (!valueInput.value || valueInput.value == "0") {
                            valueInput.value = order.total_amount || "";
                        }

                        // 2. Set ReadOnly state
                        const isFinalLocked = !canEditAmount;
                        valueInput.readOnly = isFinalLocked;
                        valueInput.style.backgroundColor = !isFinalLocked ? "#fdfdfd" : "#f7fafc";
                        valueInput.style.cursor = !isFinalLocked ? "text" : "not-allowed";
                        valueInput.title = !isFinalLocked ? "ÿ£ÿØÿÆŸÑ ŸÇŸäŸÖÿ© ÿßŸÑÿ∑ŸÑÿ®" : (role === "admin" ? "ÿ£ÿØŸÖŸÜ" : "ÿßŸÑŸÇŸäŸÖÿ© ŸÖŸÇŸÅŸÑÿ© ÿ®ÿπÿØ ÿßŸÑÿ™ÿ£ŸÉŸäÿØ");

                        saveBtn.disabled = isFinalLocked;
                        saveBtn.style.opacity = isFinalLocked ? "0.5" : "1";

                        // 3. Save Logic with Confirmation
                        saveBtn.onclick = async () => {
                            if (!canEditAmount) return;
                            const newAmount = Number(valueInput.value);
                            if (isNaN(newAmount) || newAmount < 0) {
                                Swal.fire({
                                    title: window.langu('stepper_error_title'),
                                    text: window.langu('stepper_invalid_number'),
                                    confirmButtonText: window.langu('alert_confirm_btn'),
                                    buttonsStyling: false,
                                    customClass: {
                                        popup: 'swal-modern-mini-popup',
                                        title: 'swal-modern-mini-title',
                                        htmlContainer: 'swal-modern-mini-text',
                                        confirmButton: 'swal-modern-mini-confirm'
                                    }
                                });
                                valueInput.value = order.total_amount;
                                return;
                            }

                            // Confirmation Dialog
                            const result = await Swal.fire({
                                title: window.langu('stepper_confirm_title'),
                                text: window.langu('stepper_confirm_save_text').replace('{amount}', newAmount),
                                showCancelButton: true,
                                confirmButtonText: window.langu('alert_confirm_yes'),
                                cancelButtonText: window.langu('alert_cancel_btn'),
                                buttonsStyling: false,
                                customClass: {
                                    popup: 'swal-modern-mini-popup',
                                    title: 'swal-modern-mini-title',
                                    htmlContainer: 'swal-modern-mini-text',
                                    confirmButton: 'swal-modern-mini-confirm',
                                    cancelButton: 'swal-modern-mini-cancel'
                                }
                            });

                            if (result.isConfirmed) {
                                try {
                                    saveBtn.disabled = true;
                                    valueInput.disabled = true;

                                    await updateOrderTotalAmount(order.order_key, newAmount);

                                    // Update local data
                                    order.total_amount = newAmount;

                                    Swal.fire({
                                        title: window.langu('stepper_save_success_title'),
                                        text: window.langu('stepper_save_success_text'),
                                        timer: 1500,
                                        showConfirmButton: false,
                                        buttonsStyling: false,
                                        customClass: {
                                            popup: 'swal-modern-mini-popup',
                                            title: 'swal-modern-mini-title',
                                            htmlContainer: 'swal-modern-mini-text'
                                        }
                                    });
                                } catch (err) {
                                    Swal.fire({
                                        title: window.langu('stepper_save_fail_title'),
                                        text: err.message,
                                        confirmButtonText: window.langu('alert_confirm_btn'),
                                        buttonsStyling: false,
                                        customClass: {
                                            popup: 'swal-modern-mini-popup',
                                            title: 'swal-modern-mini-title',
                                            htmlContainer: 'swal-modern-mini-text',
                                            confirmButton: 'swal-modern-mini-confirm'
                                        }
                                    });
                                    valueInput.value = order.total_amount;
                                } finally {
                                    saveBtn.disabled = false;
                                    valueInput.disabled = false;
                                }
                            }
                        };
                    }

                    // Setup Image Link if item exists
                    if (item && link) {
                        const u = order.user_key;
                        const s = item.seller_key;
                        const p = item.product_key;
                        const o = order.order_key;

                        link.onclick = (e) => {
                            e.preventDefault();
                            window.parent.orderPhotoParams = { u, s, p, o };
                            window.parent.mainLoader(`pages/orderPhoto.html?u=${u}&s=${s}&p=${p}&o=${o}`, "index-orderPhoto-container", 0, undefined, "showHomeIcon", true);
                        };
                    }
                } else {
                    serviceFooter.style.display = 'none';
                }
            }
        }
    });

    /**
     * Auto-scroll tutorial to show all stepper steps.
     * Runs only on first and second page load.
     */
    function runStepperScrollTutorial() {
        const TUTORIAL_KEY = 'stepperScrollTutorialCount';
        const MAX_RUNS = 2;
        const SCROLL_DURATION = 2000; // 2 seconds

        try {
            // Get current count
            let count = parseInt(localStorage.getItem(TUTORIAL_KEY) || '0', 10);

            console.log(`[Tutorial] Current count: ${count}, Max runs: ${MAX_RUNS}`);

            // Check if tutorial should run
            if (count >= MAX_RUNS) {
                console.log('[Tutorial] Auto-scroll tutorial already completed.');
                return;
            }

            // Increment count
            count++;
            localStorage.setItem(TUTORIAL_KEY, count.toString());
            console.log(`[Tutorial] Running auto-scroll tutorial (${count}/${MAX_RUNS})`);

            // Get the stepper wrapper (the scrollable element)
            const wrapper = document.getElementById('primary-stepper-wrapper');
            console.log('[Tutorial] Wrapper element:', wrapper);

            if (!wrapper) {
                console.warn('[Tutorial] Stepper wrapper not found.');
                return;
            }

            // Wait 1 second for content to fully render
            setTimeout(() => {
                console.log('[Tutorial] Checking scroll dimensions...');
                console.log('[Tutorial] scrollWidth:', wrapper.scrollWidth);
                console.log('[Tutorial] clientWidth:', wrapper.clientWidth);
                console.log('[Tutorial] scrollLeft (initial):', wrapper.scrollLeft);
                console.log('[Tutorial] Computed style overflow-x:', window.getComputedStyle(wrapper).overflowX);
                console.log('[Tutorial] Direction:', window.getComputedStyle(wrapper).direction);

                const maxScroll = wrapper.scrollWidth - wrapper.clientWidth;
                console.log('[Tutorial] Max scroll distance:', maxScroll);

                if (maxScroll <= 0) {
                    console.log('[Tutorial] No scroll needed, all steps visible.');
                    return;
                }

                console.log(`[Tutorial] Starting scroll animation. Max scroll: ${maxScroll}px`);

                // Detect RTL scroll behavior
                const startTime = performance.now();
                const isRTL = window.getComputedStyle(wrapper).direction === 'rtl';

                // Test RTL scroll behavior by setting a small value
                const originalScroll = wrapper.scrollLeft;
                wrapper.scrollLeft = 10;
                const testValue = wrapper.scrollLeft;
                wrapper.scrollLeft = originalScroll;

                let startScroll, endScroll;

                if (isRTL) {
                    // Check if browser uses positive or negative values for RTL
                    if (testValue > 0) {
                        // Firefox/Safari: positive values
                        startScroll = maxScroll;
                        endScroll = 0;
                        console.log('[Tutorial] RTL (positive values): scroll from', maxScroll, 'to 0');
                    } else {
                        // Chrome: negative values
                        startScroll = 0;
                        endScroll = -maxScroll;
                        console.log('[Tutorial] RTL (negative values): scroll from 0 to', -maxScroll);
                    }
                } else {
                    startScroll = 0;
                    endScroll = maxScroll;
                    console.log('[Tutorial] LTR: scroll from 0 to', maxScroll);
                }

                function animateScroll(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / SCROLL_DURATION, 1);

                    // Easing function (ease-in-out)
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                    // Calculate scroll position
                    const scrollPosition = startScroll + ((endScroll - startScroll) * easeProgress);
                    wrapper.scrollLeft = scrollPosition;

                    if (progress < 1) {
                        requestAnimationFrame(animateScroll);
                    } else {
                        console.log('[Tutorial] Forward scroll completed. Starting return animation...');
                        console.log('[Tutorial] Current scrollLeft:', wrapper.scrollLeft);

                        // Start return animation after a brief pause
                        setTimeout(() => {
                            const returnStartTime = performance.now();

                            function animateReturn(currentTime) {
                                const elapsed = currentTime - returnStartTime;
                                const progress = Math.min(elapsed / SCROLL_DURATION, 1);

                                // Easing function (ease-in-out)
                                const easeProgress = progress < 0.5
                                    ? 2 * progress * progress
                                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                                // Return to start position
                                const scrollPosition = endScroll + ((startScroll - endScroll) * easeProgress);
                                wrapper.scrollLeft = scrollPosition;

                                if (progress < 1) {
                                    requestAnimationFrame(animateReturn);
                                } else {
                                    console.log('[Tutorial] Return animation completed.');
                                    console.log('[Tutorial] Final scrollLeft:', wrapper.scrollLeft);
                                }
                            }

                            requestAnimationFrame(animateReturn);
                        }, 100); // Small pause before returning
                    }
                }

                requestAnimationFrame(animateScroll);
            }, 1000); // Wait 1 second as requested

        } catch (error) {
            console.error('[Tutorial] Error in auto-scroll tutorial:', error);
        }
    }
</script>