<div id="modal-main-content">
<!--
  @file pages/Advertiesment.html (v2 - Redesigned)
  @description نموذج إدارة إعلانات الصور (HTML Fragment) للمدير.

  هذا الملف هو جزء من واجهة المستخدم يتم تحميله ديناميكيًا داخل نافذة منبثقة (modal)
  عندما ينقر المسؤول على زر "إدارة الإعلانات". يحتوي على نموذج لإدارة صور الإعلان:
  - موديول متقدم لرفع الصور مع ضغطها من جهة العميل.
  - تحميل وعرض الصور الموجودة مسبقًا من Cloudflare R2.
  - إمكانية حذف الصور القديمة وإضافة صور جديدة.
  - شيفرة JavaScript مدمجة للتحقق من صحة النموذج، ومعالجة الصور، ورفع/حذف البيانات من R2.
-->

<!-- ✅ جديد: إضافة أنماط مخصصة لتحسين تصميم الموديول -->
<style>
  /* إعادة تصميم منطقة رفع الصور */
  #adver-form .image-uploader {
    background-color: #f8f9fa;
    border: 2px dashed #dee2e6;
    border-radius: 12px;
    padding: 2rem;
    text-align: center;
    transition: background-color 0.3s, border-color 0.3s;
    cursor: pointer;
  }

  #adver-form .image-uploader:hover {
    background-color: #f1f3f5;
    border-color: #007bff;
  }

  /* أيقونة السحابة في المنتصف */
  .dropzone-icon {
    font-size: 3rem;
    color: #adb5bd;
    margin-bottom: 1rem;
    transition: color 0.3s;
  }

  #adver-form .image-uploader:hover .dropzone-icon {
    color: #007bff;
  }

  /* رسالة السحب والإفلات */
  .dropzone-text {
    color: #495057;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  /* أزرار التحكم في الرفع */
  #adver-form .uploader-actions {
    margin-top: 1rem;
    border-top: 1px solid #e9ecef;
    padding-top: 1rem;
  }

  /* تحسين شبكة عرض الصور */
  #adver-form .previews {
    /* ✅ إصلاح شامل: استخدام CSS Grid لشبكة متجاوبة */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
    gap: 10px;
    padding: 10px;
    margin-top: 1rem;
    /* ✅ جديد: تحديد أبعاد ثابتة مع تمكين التمرير وتوسيط الصندوق */
    width: 100%;
    height: 300px;
    overflow: auto; /* تمكين التمرير الأفقي والرأسي عند الحاجة */
    background-color: #f0f2f5; /* لون خلفية لتمييز الصندوق */
    border: 1px solid #dee2e6; /* إطار بسيط */
  }

  /* تحسين بطاقة الصورة المصغرة */
  #adver-form .preview {
    position: relative;
    width: 100%;
    max-width: 120px;
    aspect-ratio: 1 / 1; /* ✅ يجعل العنصر مربع الشكل دائمًا */
    border-radius: 8px; /* ✅ تعديل: توحيد دائرية الحواف */
    overflow: hidden;
    transition: transform 0.2s ease, opacity 0.2s ease;
    background-color: #f0f0f0; /* لون خلفية احتياطي */
  }

  #adver-form .preview:hover {
    transform: translateY(-4px) scale(1.03);
    box-shadow: 0 8px 16px rgba(0,0,0,0.1);
  }

  /* ✅ جديد: إخفاء زر الحذف بشكل افتراضي */
  #adver-form .preview .remove {
    position: absolute;
    top: 5px;
    right: 5px; /* مناسب للواجهة العربية */
    background-color: rgba(220, 53, 69, 0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 0; /* إخفاء الزر */
    pointer-events: none; /* منع التفاعل معه وهو مخفي */
    transition: opacity 0.2s, transform 0.2s;
    z-index: 10;
  }

  /* ✅ جديد: إظهار زر الحذف عند تحديد الصورة */
  #adver-form .preview.selected .remove {
    opacity: 1;
    pointer-events: auto;
    transform: scale(1);
  }

  /* ✅ إصلاح: جعل الصورة تملأ الحاوية المربعة بالكامل */
  #adver-form .preview img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* يضمن ملء الصورة للمساحة دون تشويه */
    display: block;
  }

  /* حالة التحميل */
  #adver-form .preview .meta {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    font-size: 0.75rem;
    padding: 4px;
    text-align: center;
  }

  /* ✅ إصلاح: إضافة القاعدة لإخفاء حقل إدخال الملف الأصلي */
  #adver-form .hidden-file {
    position: absolute; left: -9999px;
  }

  /* ✅ جديد: أنماط خاصة بالسحب وإعادة الترتيب */
  #adver-form .preview.dragging {
    opacity: 0.7;
    transform: scale(0.95);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); /* ظل أوضح أثناء السحب */
  }

  /* خط فاصل يوضح مكان الإفلات */
  .drop-indicator {
    height: 100%;
    width: 4px;
    background-color: #007bff;
  }

  /* ✅ إصلاح: منع ظهور شريط التمرير الأفقي في النافذة */
  #adver-modal .modal-content {
    overflow-x: hidden;
  }

</style>

<div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="adverTitle">
  <button class="close-button" id="adver-modal-close-btn" aria-label="إغلاق"><i class="fas fa-times"></i></button>

  <h2 id="adverTitle"><i class="fas fa-bullhorn"></i> إدارة صور الإعلان</h2>

  <form id="adver-form" novalidate>
    <!-- موديول رفع الصور -->
    <section class="form-group" aria-labelledby="imagesHeading">
      <label id="imagesHeading"><i class="fas fa-images"></i> صور الإعلان</label>

      <div class="image-uploader" id="image-uploader" tabindex="0" role="group" aria-label="منطقة رفع الصور">
        <!-- ✅ جديد: هيكل منطقة السحب والإفلات -->
        <div class="dropzone-content">

          <p class="hint">يمكنك إضافة صور جديدة أو حذف الصور الحالية أو اسحبها لإعادة الترتيب.</p>
        </div>
        
        <input class="hidden-file" id="file-input" type="file" accept="image/*" multiple aria-hidden="true">
        
        <div class="uploader-actions" id="uploader-actions">
          <button type="button" class="btn btn-ghost btn-icon" id="pick-files-btn" title="اختر صورًا"><i class="fas fa-folder-open"></i></button>
          <button type="button" class="btn btn-ghost btn-icon" id="take-photo-btn" title="التقاط من الكاميرا"><i class="fas fa-camera"></i></button>
          <button type="button" class="btn btn-ghost btn-icon" id="clear-all-btn" title="مسح الكل"><i class="fas fa-trash-alt"></i></button>
        </div>

        <div class="previews" id="previews" aria-live="polite" aria-atomic="false">
            <div class="loader" id="images-loader" style="margin: 20px auto; display: none;"></div>
        </div>

      </div>
    </section>

    <!-- زر إرسال النموذج -->
    <div class="submit-container">
      <button type="submit" class="btn btn-primary">نشر الإعلان الآن</button>
    </div>
  </form>
</div>
</div>

<script>
/**
 * دالة لتهيئة نموذج إدارة الإعلان.
 */
async function initializeAdvertiesmentForm() {
  console.log('%c[AdverForm] Initializing form...', 'color: #20c997;');
  
  // الوصول إلى مصفوفة الصور وحالة الموديول من النطاق الخارجي
  const images = window.adverModule.images;
  images.length = 0; // إفراغ مصفوفة الصور عند كل تهيئة
  window.adverModule.originalImageNames = []; // إعادة تعيين عند كل تهيئة

  // تحميل الصور الموجودة مسبقًا
  await window.adverModule.loadExistingAdverImages();
}

// جعل الدوال والمتغيرات متاحة عالميًا ضمن نطاق النافذة
window.adverModule = (function() {
  const IMAGE_MAX_WIDTH = 1600;
  const IMAGE_MAX_HEIGHT = 1600;
  const IMAGE_QUALITY = 0.75;
  const MAX_FILES = 10;
  const R2_PUBLIC_URL = 'https://pub-e828389e2f1e484c89d8fb652c540c12.r2.dev';

  const fileInput = document.getElementById('file-input');
  const pickFilesBtn = document.getElementById('pick-files-btn');
  const takePhotoBtn = document.getElementById('take-photo-btn');
  const clearAllBtn = document.getElementById('clear-all-btn');
  const previewsEl = document.getElementById('previews');
  const uploaderEl = document.getElementById('image-uploader');
  const form = document.getElementById('adver-form');
  const imagesLoader = document.getElementById('images-loader');
  
  const images = [];
  let originalImageNames = [];
  let isDragging = false; // ✅ جديد: متغير حالة لمنع التحديثات أثناء السحب
  let idCounter = 1;

  function genId() { return 'ad_img_' + (Date.now() + idCounter++); }

  async function supportsWebP() {
    if (!self.createImageBitmap) return false;
    const blob = await fetch('data:image/webp;base64,UklGRiIAAABXRUJQVlA4TAYAAAAvAAAAAAfQ//73v/+BiOh/AAA=')
      .then(r => r.blob()).catch(()=>null);
    if (!blob) return false;
    try { await createImageBitmap(blob); return true; } catch(e) { return false; }
  }
  const WEBP_SUPPORTED_PROMISE = supportsWebP();

  async function compressImage(file) {
    const imgBitmap = await createImageBitmap(file);
    let { width, height } = imgBitmap;
    const ratio = Math.min(1, IMAGE_MAX_WIDTH / width, IMAGE_MAX_HEIGHT / height);
    const newWidth = Math.round(width * ratio);
    const newHeight = Math.round(height * ratio);
    const canvas = Object.assign(document.createElement('canvas'), { width: newWidth, height: newHeight });
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,newWidth,newHeight);
    ctx.drawImage(imgBitmap, 0, 0, newWidth, newHeight);
    const webpSupported = await WEBP_SUPPORTED_PROMISE;
    const mime = webpSupported ? 'image/webp' : 'image/jpeg';
    const blob = await new Promise((res) => canvas.toBlob(res, mime, IMAGE_QUALITY));
    try { imgBitmap.close(); } catch(e){}
    return blob;
  }

  function createPreviewItem(state, existingImageUrl = null) {
    console.log(`%c[DevLog] Creating preview for image ID: ${state.id}`, 'color: #888;');
    const wrapper = document.createElement('div');
    wrapper.className = 'preview';
    wrapper.setAttribute('data-id', state.id);

    // ✅ جديد: إضافة منطق التحديد لإظهار زر الحذف
    wrapper.addEventListener('click', (e) => {
      if (e.target.closest('.remove')) return;
      // إزالة التحديد من كل الصور الأخرى
      document.querySelectorAll('#adver-form .preview.selected').forEach(p => p.classList.remove('selected'));
      // إضافة التحديد للصورة الحالية
      wrapper.classList.add('selected');
    });


    // ✅ جديد: جعل العنصر قابلاً للسحب وإعادة الترتيب
    wrapper.draggable = true;
    wrapper.addEventListener('dragstart', (e) => {
      console.log(`%c[DevLog] Drag Start: ${state.id}`, 'color: orange;');
      isDragging = true;
      e.dataTransfer.setData('text/plain', state.id);
      setTimeout(() => wrapper.classList.add('dragging'), 0);
    });
    wrapper.addEventListener('dragend', () => {
      isDragging = false;
      wrapper.classList.remove('dragging');
    });

    const removeBtn = document.createElement('button');
    removeBtn.type = "button";
    removeBtn.className = 'remove';
    removeBtn.setAttribute('title', 'إزالة الصورة');
    removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
    removeBtn.addEventListener('click', () => removeImage(state.id));

    const img = document.createElement('img');
    const meta = document.createElement('div');
    meta.className = 'meta';

    wrapper.appendChild(removeBtn);
    wrapper.appendChild(img);
    wrapper.appendChild(meta);

    if (existingImageUrl) {
      img.src = existingImageUrl;
      meta.textContent = 'صورة حالية';
    } else {
      const reader = new FileReader();
      reader.onload = (e) => { img.src = e.target.result; };
      reader.readAsDataURL(state.file);
      meta.textContent = 'جاري الضغط...';
    }

    previewsEl.appendChild(wrapper);
    state._el = wrapper;
    state._metaEl = meta;
  }

  function removeImage(id) {
    // ✅ تعديل: تحسين رسالة التأكيد عند الحذف
    Swal.fire({
      title: 'تأكيد الحذف',
      text: "هل أنت متأكد من رغبتك في حذف هذه الصورة؟ لا يمكن التراجع عن هذا الإجراء.",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#d33',
      target: document.getElementById('modal-main-content'), // ✅ إصلاح: جعل الرسالة تظهر فوق النافذة الحالية
      cancelButtonColor: '#3085d6',
      confirmButtonText: 'موافق',
      cancelButtonText: 'إلغاء'
    }).then((result) => {
      if (result.isConfirmed) {
        const idx = images.findIndex(i => i.id === id);
        if (idx > -1) {
          const state = images[idx];
          if (state._el) state._el.remove();
          console.log(`%c[DevLog] Image removed from UI: ${id}`, 'color: red;');
          images.splice(idx, 1);
        }
      }
    });
  }

  function clearAll() {
    if (images.length === 0) return;
    Swal.fire({
      title: 'هل أنت متأكد؟',
      text: "سيتم حذف جميع الصور المضافة!",
      icon: 'warning',
      showCancelButton: true,
      target: document.getElementById('modal-main-content'), // ✅ إصلاح: جعل الرسالة تظهر فوق النافذة الحالية
      confirmButtonText: 'نعم، احذف الكل!', 
      cancelButtonText: 'إلغاء'
    }).then((result) => {
      if (result.isConfirmed) {
        console.log('%c[DevLog] Clearing all images from UI.', 'color: red;');
        previewsEl.innerHTML = '';
        images.length = 0;
      }
    });
  }

  async function handleNewFiles(fileList){
    console.log(`%c[DevLog] Handling ${fileList.length} new files.`, 'color: blue;');
    const filesArr = Array.from(fileList).slice(0, MAX_FILES - images.length);
    for(const file of filesArr){
      if(!file.type.startsWith('image/')) continue;
      const id = genId();
      const state = { id, file, compressedBlob: null, status:'pending' };
      images.push(state);
      createPreviewItem(state);
      try{
        console.log(`%c[DevLog] Compressing image: ${file.name}`, 'color: #888;');
        state.status = 'compressing';
        const compressed = await compressImage(file);
        state.compressedBlob = compressed;
        state.status = 'ready';
        if (state._metaEl) state._metaEl.textContent = 'جاهزة';
      } catch(err){
        state.status = 'error'; console.error(`[DevLog] Compression failed for ${file.name}`, err);
        if (state._metaEl) state._metaEl.textContent = 'خطأ';
      }
    }
    fileInput.value = '';
  }
let stop =0;
  async function loadExistingAdverImages() {
    if(stop==0){
      stop=1;
      try{
    console.log('%c[DevLog] 1. Loading existing advertisement images...', 'color: blue; font-weight: bold;');
    imagesLoader.style.display = 'block';
    previewsEl.innerHTML = '';
    images.length = 0;
    originalImageNames = [];

    // ✅ تحسين: استخدام طريقة التحقق من وجود الصورة عبر new Image() لتجنب مشاكل CORS المعقدة
    const imagePromises = [];
    for (let i = 1; i <= MAX_FILES; i++) {
      const imageName = `pic${i}.webp`;
      // ✅ إصلاح: إضافة معلمة فريدة لتجاوز ذاكرة التخزين المؤقت للمتصفح وضمان جلب أحدث حالة للصورة
      const imageUrl = `${R2_PUBLIC_URL}/${imageName}?v=${Date.now()}`;

      const promise = new Promise((resolve) => {
        // لا نستخدم fetch هنا لتجنب مشاكل CORS عند مجرد التحقق
        const checker = new Image();
        checker.onload = () => { 
          console.log(`%c[DevLog]   - Found: ${imageName}`, 'color: green;');
          resolve({ success: true, name: imageName, url: imageUrl });
        };
        checker.onerror = () => {
          // console.log(`%c[DevLog]   - Not Found: ${imageName}`, 'color: #aaa;');
          // فشل التحميل يعني أن الصورة غير موجودة
          resolve({ success: false, name: imageName });
        };
        checker.src = imageUrl;
      });
      imagePromises.push(promise);
    }

    const results = await Promise.all(imagePromises);
    results.forEach(result => {
      if (result.success) {
        originalImageNames.push(result.name);
        const id = genId();
        const state = { id, file: null, compressedBlob: null, status: 'uploaded', fileName: result.name };
        images.push(state);
        createPreviewItem(state, result.url);
      }
    });

    window.adverModule.originalImageNames = originalImageNames;
    console.log(`%c[DevLog] Finished loading. Found ${originalImageNames.length} images.`, 'color: blue; font-weight: bold;');
    imagesLoader.style.display = 'none';
    stop=0;
  }catch(err){
    stop=0;
    console.error ("خطا في تحميل الصور:", err);

  }
  }
  }

  pickFilesBtn.addEventListener('click', () => {
    fileInput.removeAttribute('capture');
    fileInput.click();
  });

  // ✅ جديد: منطق مشروط ومحسّن لزر الكاميرا
  takePhotoBtn.addEventListener('click', () => {
    // 1. التحقق إذا كان الجهاز محمولاً
    const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

    if (isMobile) {
      // السلوك الحالي للهواتف: استخدام capture لفتح تطبيق الكاميرا الأصلي
      console.log('[AdverForm Camera] Mobile device detected. Using capture attribute.');
      fileInput.setAttribute('capture', 'environment');
      fileInput.click();
    } else {
      // السلوك الجديد لأجهزة سطح المكتب: استخدام getUserMedia
      console.log('[AdverForm Camera] Desktop device detected. Using getUserMedia API.');
      openDesktopCamera();
    }
  });

  /**
   * ✅ جديد: دالة لفتح كاميرا الويب على أجهزة سطح المكتب.
   *    (هذه الدالة مضافة داخل نطاق <script> الخاص بموديول الإعلانات)
   */
  async function openDesktopCamera() {
    // ملاحظة: الحاوية camera-modal-container موجودة بالفعل في admin.html
    const cameraModalContainer = document.getElementById('camera-modal-container');
    if (!cameraModalContainer) {
      console.error('Camera modal container not found in admin.html!');
      return;
    }

    // 1. إنشاء واجهة المستخدم لنافذة الكاميرا
    cameraModalContainer.innerHTML = `
      <div class="modal-content camera-modal-content">
        <button class="close-button" id="camera-modal-close-btn" aria-label="إغلاق"><i class="fas fa-times"></i></button>
        <video id="camera-preview" autoplay playsinline></video>
        <canvas id="camera-canvas" style="display:none;"></canvas>
        <div class="camera-controls">
          <button id="capture-photo-btn" class="btn btn-primary"><i class="fas fa-camera"></i> التقاط الصورة</button>
        </div>
      </div>
    `;
    cameraModalContainer.style.display = 'flex';

    const video = document.getElementById('camera-preview');
    const captureBtn = document.getElementById('capture-photo-btn');
    const closeBtn = document.getElementById('camera-modal-close-btn');

    // 2. طلب الوصول إلى الكاميرا
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
      video.srcObject = stream;

      const closeStream = () => {
        stream.getTracks().forEach(track => track.stop());
        cameraModalContainer.style.display = 'none';
        cameraModalContainer.innerHTML = '';
      };

      closeBtn.onclick = closeStream;

      captureBtn.onclick = () => {
        const canvas = document.getElementById('camera-canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        canvas.toBlob(blob => {
          handleNewFiles([blob]); // استخدام نفس الدالة لمعالجة الصورة الملتقطة
          closeStream(); // إغلاق النافذة بعد الالتقاط
        }, 'image/jpeg', 0.9);
      };
    } catch (err) {
      console.error("Error accessing camera: ", err);
      Swal.fire({ title: 'خطأ!', text: 'لم نتمكن من الوصول إلى الكاميرا. يرجى التأكد من منح الإذن اللازم.', icon: 'error', target: document.getElementById('modal-main-content') });
      cameraModalContainer.style.display = 'none';
    }
  }

  clearAllBtn.addEventListener('click', clearAll);
  fileInput.addEventListener('change', (e) => handleNewFiles(e.target.files));

  // --- ✅ جديد: إضافة دعم السحب والإفلات باللمس للشاشات المحمولة ---
  let draggingElTouch = null;

  previewsEl.addEventListener('touchstart', (e) => {
    const target = e.target.closest('.preview');
    if (!target) return;

    console.log('%c[DevLog] Touch Start', 'color: orange;');
    isDragging = true;
    draggingElTouch = target;
    // تأخير بسيط لإضافة الكلاس للسماح للمتصفح بالاستجابة
    setTimeout(() => {
      if (draggingElTouch) draggingElTouch.classList.add('dragging');
    }, 100);
  }, { passive: true });

  // ✅ جديد: استخدام Debounce لتحسين أداء السحب
  const debouncedTouchMove = debounce((e) => {
    if (!isDragging || !draggingElTouch) return; // لا تفعل شيئًا إذا لم يكن هناك سحب نشط

    const touch = e.touches[0];
    // ✅ إصلاح: منع تمرير الصفحة فقط عند السحب الفعلي
    // هذا يضمن أن التمرير العادي يعمل عندما لا يتم سحب أي عنصر
    if (e.cancelable) e.preventDefault();
    const afterElement = getDragAfterElement(previewsEl, touch.clientX, touch.clientY);

    if (afterElement == null) {
      previewsEl.appendChild(draggingElTouch);
    } else {
      previewsEl.insertBefore(draggingElTouch, afterElement);
    }
  }, 30);

  previewsEl.addEventListener('touchmove', debouncedTouchMove, { passive: false });

  previewsEl.addEventListener('touchend', (e) => {
    if (!draggingElTouch) return;

    isDragging = false;
    // ✅ إصلاح: إزالة صنف السحب عند انتهاء اللمس
    draggingElTouch.classList.remove('dragging');
    draggingElTouch = null;

    // تأخير بسيط للتأكد من أن الواجهة استقرت قبل تحديث المصفوفة
    setTimeout(() => {
      updateImageOrderFromDOM();
      console.log('%c[DevLog] Images reordered via touch.', 'color: purple;');
    }, 50);
  });

  // ✅ جديد: دالة مركزية لتحديث ترتيب مصفوفة الصور من الواجهة
  function updateImageOrderFromDOM() {
    // ✅ إصلاح: تحديث ترتيب مصفوفة `images` الداخلية ليعكس الترتيب المرئي
    const newOrderedIds = Array.from(previewsEl.querySelectorAll('.preview')).map(el => el.dataset.id);
    const newImagesArray = newOrderedIds.map(id => images.find(img => img.id === id));
    // استبدال المصفوفة القديمة بالجديدة
    images.length = 0;
    images.push(...newImagesArray);
    console.log(`%c[DevLog]   - New order: [${newOrderedIds.join(', ')}]`, 'color: purple;');
  }

  // ✅ جديد: منطق السحب والإفلات لإعادة الترتيب
  const debouncedDragOver = debounce((e) => {
    e.preventDefault();
    if (!isDragging) return;
    const draggingEl = document.querySelector('.preview.dragging');
    if (!draggingEl) return;

    const afterElement = getDragAfterElement(previewsEl, e.clientX, e.clientY);
    if (afterElement == null) {
      previewsEl.appendChild(draggingEl);
    } else {
      previewsEl.insertBefore(draggingEl, afterElement);
    }
  }, 30);

  previewsEl.addEventListener('dragover', debouncedDragOver);

  previewsEl.addEventListener('drop', (e) => {
    e.preventDefault();
    isDragging = false;
    const draggingEl = document.querySelector('.preview.dragging');
    if (!draggingEl) return;

    updateImageOrderFromDOM();
    console.log('%c[DevLog] Images reordered via drop.', 'color: purple;');
  });

  // ✅ جديد: دالة Debounce لتحسين الأداء
  function debounce(fn, delay = 50) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn(...args), delay);
    };
  }

  // ✅ إصلاح شامل: منطق جديد للسحب والإفلات يعتمد على أقرب عنصر
  function getDragAfterElement(container, x, y) {
    const draggableElements = [...container.querySelectorAll('.preview:not(.dragging)')];

    // البحث عن أقرب عنصر للمؤشر
    const closest = draggableElements.reduce((acc, child) => {
        const box = child.getBoundingClientRect();
        // حساب المسافة من منتصف العنصر إلى المؤشر
        const offsetX = x - (box.left + box.width / 2);
        const offsetY = y - (box.top + box.height / 2);
        const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);

        if (distance < acc.distance) {
            return { distance: distance, element: child };
        } else {
            return acc;
        }
    }, { distance: Number.POSITIVE_INFINITY, element: null });

    return closest.element;
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    console.log('%c[DevLog] 2. Submit event triggered. Starting sync process...', 'color: blue; font-weight: bold;');

    Swal.fire({
      title: 'جاري نشر الإعلان...',
      text: 'الرجاء الانتظار بينما يتم تحديث الصور.',
      allowOutsideClick: false,
      target: document.getElementById('modal-main-content'), // ✅ إصلاح: جعل الرسالة تظهر فوق النافذة الحالية
      didOpen: () => { Swal.showLoading(); },
    });

    try {
      // --- ✅ إصلاح شامل لمنطق الحفظ ---

      console.groupCollapsed('%c[DevLog] Sync Plan', 'color: #0d6efd; font-weight: bold;');
      // 1. تحديد الحالة النهائية للصور في الواجهة (UI) وتسميتها بالترتيب
      const finalImagesInUI = images.map((state, index) => ({
        state: state,
        newName: `pic${index + 1}.webp`
      }));
      const finalImageNamesInUI = finalImagesInUI.map(item => item.newName);

      console.log('Final UI State:', finalImageNamesInUI);

      // 2. تحديد الصور للحذف: أي صورة كانت موجودة أصلاً ولم تعد موجودة في الواجهة
      const currentUploadedFileNames = images.filter(s => s.status === 'uploaded').map(s => s.fileName);
      const removedImageNames = window.adverModule.originalImageNames.filter(name => !currentUploadedFileNames.includes(name));

      // وأيضًا، أي "خانات" لم تعد مستخدمة في الترتيب النهائي
      const allPossibleNames = Array.from({ length: MAX_FILES }, (_, i) => `pic${i + 1}.webp`);
      const unusedFinalSlots = allPossibleNames.filter(name => !finalImageNamesInUI.includes(name));
      const imagesToDelete = [...new Set([...removedImageNames, ...unusedFinalSlots])];

      console.log('Images to Delete:', imagesToDelete);

      // 3. تحديد الصور الجديدة للرفع والصور الموجودة لإعادة الترتيب
      const newUploadsPlan = finalImagesInUI.filter(item => item.state.status === 'ready');
      const reorderItemsPlan = finalImagesInUI.filter(item => item.state.status === 'uploaded' && item.state.fileName !== item.newName);
      console.log('New Images to Upload:', newUploadsPlan.map(i => i.newName));
      console.log('Images to Reorder:', reorderItemsPlan.map(i => `${i.state.fileName} -> ${i.newName}`));

      console.groupEnd();

      // 4. تنفيذ عمليات الحذف أولاً وبشكل منفصل لضمان إفراغ الخانات
      if (imagesToDelete.length > 0) {
        console.groupCollapsed(`%c[DevLog] Deletion Phase (${imagesToDelete.length} images)`, 'color: #dc3545;');
        console.log("Deleting:", imagesToDelete);
        await Promise.all(imagesToDelete.map(name =>
          deleteFile2cf(name).catch(err => console.error(`Failed to delete ${name}:`, err))
        ));
        console.groupEnd();
      }

      // 5. رفع الصور الجديدة فقط
      const newUploads = finalImagesInUI.filter(item => item.state.status === 'ready' && item.state.compressedBlob);
      if (newUploads.length > 0) {
        console.groupCollapsed(`%c[DevLog] Upload Phase (${newUploads.length} new images)`, 'color: #198754;');
        console.log("Uploading:", newUploads.map(item => item.newName));
        await Promise.all(newUploads.map(item => 
          uploadFile2cf(item.state.compressedBlob, item.newName)
        ));
        console.groupEnd();
      }

      // 6. التعامل مع إعادة الترتيب بأمان على ثلاث مراحل (نسخ احتياطي -> نشر -> تنظيف)
      const reorderItems = finalImagesInUI.filter(item => item.state.status === 'uploaded' && item.state.fileName !== item.newName);
      if (reorderItems.length > 0) {
        console.groupCollapsed(`%c[DevLog] Reorder Phase (${reorderItems.length} images)`, 'color: #fd7e14; font-weight: bold;');

        // المرحلة أ: النسخ الاحتياطي (إعادة التسمية إلى أسماء مؤقتة)
        console.groupCollapsed('Step A: Backup to Temporary');
        const backupPromises = reorderItems.map(async (item) => {
          const tempName = `temp_${item.state.fileName}`;
          console.log(`  - Backing up '${item.state.fileName}' to '${tempName}'`);
          const blob = await downloadFile2cf(item.state.fileName);
          await uploadFile2cf(blob, tempName);
          return { tempName, finalName: item.newName, originalName: item.state.fileName };
        });
        const backedUpFiles = await Promise.all(backupPromises);
        console.groupEnd();

        // المرحلة ب: النشر النهائي (إعادة التسمية من المؤقت إلى النهائي)
        console.groupCollapsed('Step B: Finalize from Temporary');
        const finalizePromises = backedUpFiles.map(async (file) => {
          console.log(`  - Finalizing '${file.tempName}' to '${file.finalName}'`);
          const blob = await downloadFile2cf(file.tempName);
          return uploadFile2cf(blob, file.finalName);
        });
        await Promise.all(finalizePromises);
        console.groupEnd();

        // المرحلة ج: التنظيف (حذف الملفات المؤقتة والأصلية التي تم نسخها)
        console.groupCollapsed('Step C: Cleanup');
        const cleanupPromises = backedUpFiles.map(file => {
          console.log(`  - Cleaning up temp file: '${file.tempName}'`);
          return deleteFile2cf(file.tempName).catch(err => console.error(`Cleanup failed for ${file.tempName}:`, err));
        });
        await Promise.all(cleanupPromises);

        // حذف الملفات الأصلية التي تم نسخها احتياطيًا
        const deleteOriginalsPromises = backedUpFiles.map(file => {
            console.log(`  - Cleaning up original file: '${file.originalName}'`);
            return deleteFile2cf(file.originalName).catch(err => console.error(`Cleanup failed for original ${file.originalName}:`, err));
        });
        await Promise.all(deleteOriginalsPromises);
        console.groupEnd();

        console.groupEnd(); // End Reorder Phase
      }
      
      // --- نهاية منطق المزامنة ---
      
      // 7. تسجيل تاريخ التحديث في جدول updates
      console.log('%c[DevLog] 3. Recording update timestamp...', 'color: blue; font-weight: bold;');
      if (typeof addUpdate === 'function') {
        await addUpdate("تم تحديث صور الإعلانات");
      }

      // ✅ إصلاح: إضافة خاصية 'target' لضمان ظهور الرسالة فوق النافذة
      Swal.fire({
        title: 'تم بنجاح!',
        text: 'تم نشر الإعلان بنجاح.',
        icon: 'success',
        target: document.getElementById('modal-main-content')
      }).then(() => {
        // إعادة تحميل المعاينة لتحديث الحالة
        initializeAdvertiesmentForm();
      });

    } catch (error) {
      // ✅ تحسين: تسجيل الخطأ بشكل أوضح للمطور
      console.error('%c[DevLog] Submission failed with critical error. The operation was stopped.', 'color: red; font-weight: bold;', { errorObject: error, fullState: { images, originalImageNames } });
      // ✅ إصلاح: إضافة خاصية 'target' لضمان ظهور الرسالة فوق النافذة
      Swal.fire({ title: 'خطأ!', text: `فشل في نشر الإعلان: ${error.message}`, icon: 'error', target: document.getElementById('modal-main-content') });
    }
  });

  return {
    images,
    originalImageNames: [],
    genId,
    createPreviewItem,
    loadExistingAdverImages
  };

})(); // نهاية الوحدة
</script>